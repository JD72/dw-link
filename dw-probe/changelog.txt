Version 0.1 (27-May-21)
  - initial version with only a minimal amount of coverage
  - can connect via serial interface to host
  - 'monitor init' establishes the connection to the target
  - 'monitor stop' switches the MCU back to the normal state
  - more accurate baud determination than in other programs based on TIMER1!
  - already all high-level functions from avr_debug (?,H,T,g,G,m,M (except flash),
    D, k, c, s (not functional yet), z, Z, v, q) are implemented
  - all relevant low level functions from DebugWireDebuggerProgrammer are ported
  - erase flash page implemented

Version 0.2 (28-May-21)
  - writing to flash works
  - loading a file works (using the M command and X commands)

Version 0.3 (28-May-21)
  - fixed problem with not being able to read the PC after a break
  - use LED_BUILTIN to signal system status
  - fixed breakpoint address problem (converting from word to byte addresses)
  - fixed inconsistent PC addresses (byte vs. word)
  - hw breakpoint integrated

Version 0.4 (29-MAY-21)
  - use of hw breakpoint as one of the ordinary breakpoints
  - new used field in bp struct
  - works now in PlatformIO (if one uses a .gdbinit file!)
  - fixed bp address bug

Version 0.5 (31-May-21)
  - less register saving and restoring makes single-stepping faster!
  - fixed problem with clobbered PC after offline execution of insturuction by
    incrementing internal PC twice
  - also disallowed branching / jumping / calling / returning instructions in this context
  - dynamic assignment of HW breakpoint:
    if the same address is used twice in a row for a HW breakpoint and the second time
    there is another breakpoint that has not been written to flash memory yet,
    we reassign the HW BP to the new breakpoint. This way, the HW breakpoint
    is more effectively used for single-stepping dynamic breakpoints, e.g. overstepping
    a function.
  - changed the handling of too many breakpoints to using an error message
    when a breakpoint beyond the limit is going to be inserted. This allows us
    to continue when we have been stopped using a temporary breakpoint inserted by GDB
  - new monitor command "flashcount" that reports on how often a flash page write operation
    had occured.
  - new monitor command "ram" that reports on the minimal number of free bytes in RAM,
    this command is usually disabled, though (see compile time constant FREERAM).
  - added '*' as an charachter to be escaped in bin2mem; the documentation says that
    it only needs to be escaped when comming from the stub, but avr-gdb seems to escape it
    anyway.

Version 0.6 (03-Jun-21)
  - added support for ATtiny828 and ATtiny43
  - issue an error when a byte is escaped although it should not have been instead
    of silently ignoring it
  - added gdbRemoveAllBreakpoints in order to avoid leaving active bps before reset etc.
  - changed the number of entries of bp from MAXBREAKS*2+1 to one less, because we now
    refuse to acknowledge every extra BP above the allowed number
  - detach function now really detaches, i.e., continues execution on the target and leaves it alone.

Version 0.7 (03-Jun-21)
  - implementation of monitor ckdivX (promised already in the manual)

Version 0.8 (08-Jun-21)
  - problem with unsuccessful erase operations fixed: was actually an I/O unsynchronization bug.
    Forgot to read the BREAK/'U' after the single-step operation when skipping a SW breakpoint
    in gdbStepOverBP.
  - added message explaining connection error

Version 0.9 (30-Jun-21)
  - make distinction between wiring error and unsupported MCU type when connecting
  - implement automatic power-cycling
  - waiting longer after trying to power-cycle before requesting it in order to avoid
    the message to "power-cycle" 
  - not confusing the user by saying that dW is "still enabled". You always get that it is
    "now enabled"
  
Version 0.9.1 (02-Jul-21)
  - added "defensive code" into the debugger that detects fatal errors
    such as page erase failures and then reports them to the user
    instead of silently ignoring it
  - added code to detect loss of connection to the target
  - added code to detect when lock bits are set
  - excluded all MCUs with bootloader memory

Version 0.9.2 (04-Jul-21)
  - show speed of connection when calling "monitor init"
  - initialize all vars when gdb reconnects (i.e., when gdb sends a qSupported packet)
  - now we use TIMER1 for measuring the delay instead of counting execution cycles in
    OnePinSerial: much more accurate!
  - since this is still not enough, the millis and the status blinking interrupts have been
    disabled (we now use _delay_ms and _delay_us); actually, the blink IRQ is now only used
    for error blinking and for power-cycle
    flashing -- all other interrupts are disabled, except, of course, for the
    PCI interrupt for the debugWIRE line and the interrupt for the serial line;
  - in order to get the center of the first bit, we now wait for 1,5 bits after the first edge
    (minus the time used in the program for serving the IRQ etc - which is empirically determined);
  - changed setTimeoutDelay(DWIRE_RATE) to setTimeoutDelay(ctx.baud) in order to minimize the delay
    in the getResponse loop; it used to be 4ms, which was ridiculous and showed badly with the
    new OnePinSerial class;
  - in addition, the targetReset routine needed a seperate delay loop because the delay to the
    response is not depended on the baud rate, but it is constant 75ms;
  - finally, we can now also write flash memory in the ATmegas, so the exclusion of the
    bootloader MCUs has been revoked

Version 0.9.3 (04-Jul-21)
  - Now it seems to work with targets running at 16 MHz. With SCOPE_TIMING enabled in OnePinSerial,
    it worked beautifully; without, there were a number of glitches when reading.
    So I put in some NOPs when SCOPE_TIMING is disabled ... and it
    works. The only problem is, I do not know why, and this makes me nervous. Maybe time
    to rework OnePinSerial from the ground up.

Version 0.9.4 (02-Nov-21)
  - Instead of OnePinSerial, we use now dwSerial, which uses in turn the (new) base class SingleWireSerial.
    One order of magnitude more accurate and robust! Works up to 250 kbps without a hickup
    (if the millis interrupt is disabled).
  - Timeout in getResponse is now done using the number of cycle iterations, which is roughly 2-3us.
    Meaning we should wait roughly 40,000 iterations if we want to wait up to 100 ms (works so far).

Version 0.9.5 (04-Nov-21)
  - changed the TXOnlySerial bps to 57600
  - decreased timeout for "power-cycle" to 3 seconds in order to supress "timeout" message by gdb 
  - all basic debugWIRE functions have now a DW prefix
  - created "monitor testtg" and "monitor testgdb" for unit testing the target functions
    and the gdb functions, but have to come up with unit tests for them
  - inserted "unit test" code for low level DebugWIRE functions, which can be called using
    "monitor testdw"
  - registers are only saved (right after start or after a break) and restored (before
    execution or single-stepping)
    no more partial saves etc. Is much faster since we use the bulk register transfer.
  - no more noJumpInstr() since jumps can actually be executed offline
  - calls to dw.sendCmd replaced by calls to new function sendCommand, which now waits for
    Serial output to be finished in order to avoid any output interrupt, which can
    take up to 8.75 us
    and by that confuse SingleWireSerial. It can withstand 6.6 us, but 8.75 us is too
    much at 125 kbps!

Version 0.9.6 (04-Nov-21)
  - reshuffeld code in gdbConnect without external effects. Added a case for "unknown reason"
    for a connection error.
  - added more DW test cases and streamlined DW unit tests
  - added target unit tests 
  - added a 'monitor testall' command that executes all unit tests

Version 0.9.7 (06-Nov-21)
  - new HWBP policy: most recently inserted BP will become a HWBP,
    i.e., it will steal the property from BPs earlier introduced
  - cleaned up gdbUpdateBreakpoints (no hwbp assignment anymore)
  - streamlined BP removal function, no early freeing of BPs
  - in InsertBreakpoint we may steal the HWBP from another breakpoint
  - new function gdbBreakpointPresent, which returns true if a BREAK instruction
    has been inserted by us and then gives back opcode and 2nd word, if necessary
  - redesign of gbdStepOverBP and renaming it to gdbBreakDetour:
    for 2-byte instructions, we execute offline (using debugWIRE)
    for 4-byte instructions, we simulate the execution
  - unit tests for breakpoint management, single-step, and execution
  - removed gdbRemoveAllBreakpoints and replaced it by a check
    for remaining breakpoints (there shouldn't be any)
  - hide inactive breakpoints in memory to the eyes of gdb when
    gdb asks for flash memory contents
  - introduced bpused (number of used BPs) as a  second BP counter  (in order
    to speed up processing when nothing is there)

Version 0.9.8
  - some attiny chips exhibit a somewhat funny behavior
    when they are connected to debugWIRE: you need to send a LONG break to which the
    chip responds with a 'U' with roughly 4000 bps; when you then send
    a reset command (0x07), the chip answers with a break and 'U' using the
    right speed (clk/128); so, I had to redesign the connection
    routine, which hopfully also works for the other chips: turns out, it does;
    moreover, the funny chips seem to work normal after going through
    the motion once, i.e., disabling the DWEN bit again. After that
    they respond after the first break with the right speed
  - while the DWDR register of the ATtiny 2313 is 0x1F, the one for the 4313 
    is 0x27 instead
  - fixed the problem that page writes on the ATmega did not always work (the
    program did not wait long enough, although the code was already there)
  - inserted code to deal with the 4-page erase operations of 1634, 841, 441; new field in the
    mcu record	and code; the pagesize will be treated as 4 times as large (mcu.targepgsz),
    and while programming the page, 4 write operations take place
  - put the SingleWireSerial library into the src directory together
    with dwSerial
  - before any monitor command, the breakpoints will be deleted from
    memory
  - all global vars are initialized when monitor init is executed
  - the name of the connected MCU is shown when connecting
  - enabled blinking interrupt now again when MCU is running;
    interrupt latency is down to 3.4 us, which is tolerable
    for SingleWireSerial
  - noticed that when we use the BUILTIN_LED, then this will blink the
    BUILTIN_LED of the target, since the SCK lines of debugger and
    target are connected; so switched to PB2 (Arudino pin 2) for the system LED
  - when running the ATmega328 target on 16 MHz, sometimes spurious
    0x00/0xFF show up; so I introduced DWflushInput taht reads them
    away; what is strange is that this does not happen at lower
    frequencies and not with other chips at 16 MHz; it also quite determinstic!
  - Unit tests successful on:
    Attiny13 (9.6 MHz, 1.2 MHz)
    ATtiny2313 (8 MHz, 1 MHz)
    ATtiny4313 (8 MHz, 1 MHz)
    ATtiny24 (8 MHz, 1 MHz)
    ATtiny84 (8 MHz, 1 MHz)
    ATtiny85 (8 MHz, 1 MHz)
    ATtiny861 (8 MHz, 1 MHz)
    ATTiny167 (16 MHz, 2 MHz)
    ATtiny1634 (8 MHz, 1 MHz)
    ATmega328P (16 MHz, 8 MHz, 2 MHz, 1 MHz)
   
    
